var attributeMap={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"};var DEBUG=false;var decoder=null;function AttributeToArray(r,e,o,t,a,n){if(n.ptr===0){var c="No attribute "+t;console.error(c);throw new Error(c)}var i=n.num_components();var d=o.num_points();var s=d*i;var l;var u=new ArrayBuffer(s*a.BYTES_PER_ELEMENT);var D;var A="";switch(a){case Float32Array:l=new r.DracoFloat32Array;e.GetAttributeFloatForAllPoints(o,n,l);D=new Float32Array(u);A="f32";break;case Int8Array:l=new r.DracoInt8Array;e.GetAttributeInt8ForAllPoints(o,n,l);D=new Int8Array(u);A="i8";break;case Int16Array:l=new r.DracoInt16Array;e.GetAttributeInt16ForAllPoints(o,n,l);D=new Int16Array(s);A="i16";break;case Int32Array:l=new r.DracoInt32Array;e.GetAttributeInt32ForAllPoints(o,n,l);D=new Int32Array(s);A="i32";break;case Uint8Array:l=new r.DracoUInt8Array;e.GetAttributeUInt8ForAllPoints(o,n,l);D=new Uint8Array(s);A="u8";break;case Uint16Array:l=new r.DracoUInt16Array;e.GetAttributeUInt16ForAllPoints(o,n,l);D=new Uint16Array(s);A="u16";break;case Uint32Array:l=new r.DracoUInt32Array;e.GetAttributeUInt32ForAllPoints(o,n,l);D=new Uint32Array(s);A="u32";break;default:var c="DRACOWorker: Unexpected attribute type.";console.error(c);throw new Error(c)}for(var f=0;f<s;f++){D[f]=l.GetValue(f)}r.destroy(l);if(DEBUG){console.log("Attribute type: "+t+", components: "+i,u)}return{buffer:u,components:i,bytesPerElement:a.BYTES_PER_ELEMENT,type:A}}function getTime(){return(new Date).getTime()}function decodeDraco(r,e,o){dracoDecoder=o;var t=new dracoDecoder.Decoder;var a=new dracoDecoder.DecoderBuffer;a.Init(new Int8Array(e),e.byteLength);var n=t.GetEncodedGeometryType(a);if(n==dracoDecoder.TRIANGULAR_MESH){if(DEBUG){console.log("Draco Worker: Loaded a mesh.")}}else if(n==dracoDecoder.POINT_CLOUD){if(DEBUG){console.log("Draco Worker: Loaded a point cloud.")}}else{var c="Draco Worker: Unknown geometry type.";console.error(c);throw new Error(c)}var i=getTime();if(DEBUG){console.log("Draco Worker: Starting decode.")}var d=new dracoDecoder.Mesh;var s=t.DecodeBufferToMesh(a,d);if(DEBUG){console.log("Decoded in "+(getTime()-i)+" ms, status=",s)}dracoDecoder.destroy(a);var l;if(n==dracoDecoder.TRIANGULAR_MESH){l=d.num_faces();if(DEBUG){console.log("Number of faces loaded: "+l.toString())}}else{l=0}var u=d.num_points();var D=d.num_attributes();if(DEBUG){console.log("Number of points loaded: "+u.toString());console.log("Number of attributes loaded: "+D.toString())}var A=t.GetAttributeId(d,dracoDecoder.POSITION);if(A==-1){var c="Draco Worker: No position attribute found in model.";console.error(c);dracoDecoder.destroy(d);throw new Error(c)}var f={command:"decode",jobId:r,attributes:{}};var y=[];for(var m in attributeMap){if(DEBUG){console.log("attribute: "+m)}var b=t.GetAttributeId(d,dracoDecoder[attributeMap[m]]);if(b!==-1){if(DEBUG){console.log("Loaded "+m+" attribute.")}var w=t.GetAttribute(d,b);f.attributes[m]=AttributeToArray(dracoDecoder,t,d,m,Float32Array,w);y.push(f.attributes[m].buffer);if(DEBUG){console.log(m+" array is: ",array)}}}var v=l*3;var E=new ArrayBuffer(v*Uint32Array.BYTES_PER_ELEMENT);var U=new Uint32Array(E);var G=new dracoDecoder.DracoInt32Array;for(var I=0;I<l;++I){t.GetFaceFromMesh(d,I,G);var g=I*3;U[g]=G.GetValue(0);U[g+1]=G.GetValue(1);U[g+2]=G.GetValue(2)}dracoDecoder.destroy(G);if(DEBUG){console.log("Decoded numIndices: "+v)}y.push(E);f.indeces=E;if(DEBUG){console.log(y)}postMessage(f,y)}onmessage=function(r){if(!r.data.hasOwnProperty("command")){console.log("Draco worker: Missing command in worker message.");return}if(r.data.command=="decode"){if(DEBUG){console.log("Draco worker: Decoding.")}decodeDraco(r.data.jobId,r.data.buffer,decoder)}else if(r.data.command=="init"){if(decoder==null){importScripts(r.data.scriptPath);var e={};e.type=r.data.decoderType;if(e.type=="wasm"){e.wasmBinary=r.data.wasmBinary}e.onModuleLoaded=function(r){decoder=r;postMessage("ready")};DracoDecoderModule(e)}}else{console.log("Draco worker: Unknown command : "+r.data.command)}};